"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['app', 'rt', 'create_app', 'index', 'edit', 'open', 'iter_file', 'CollapsibleBlocks', 'embed']

# %% ../nbs/00_core.ipynb 3
from fasthtml.common import *
from monsterui.all import *
from .commons import config, MountPaths, ResponseTypes, ExtensionTypes
from memexplatform.ui.structure import ifhtmx
from .mdmanager import ObsidianHTMLRenderer, get_subdirs, resolve_note_path
from mistletoe import Document
import urllib
from typing import Optional
import pathlib
from pathlib import Path
from .mdmanager import ObsidianPage, guess_mime
from .datastore import DBStore, FileStore
from io import BytesIO

# %% ../nbs/00_core.ipynb 5
def create_app():
    hdrs = Theme.neutral.headers(highlightjs=True)
    Mermaid = MermaidJS()
    Katex = KatexMarkdownJS()
    D3 = Script(src="https://cdn.jsdelivr.net/npm/d3@7")
    PyscriptCSS=Link(rel="stylesheet", href="https://pyscript.net/releases/2025.3.1/core.css", type="text/css"),
    PyscriptJS=Script(src="https://pyscript.net/releases/2025.3.1/core.js", type='module')
    SurrealGlobalAdd = Script("surreal.globalsAdd());");
    Plotly = Script(src="https://cdn.plot.ly/plotly-3.0.1.min.js")
    add_hdrs = [Mermaid, Katex, D3, PyscriptCSS, PyscriptJS, SurrealGlobalAdd, Plotly]
    newhdrs = hdrs +add_hdrs
    mount_routes = []

    app = FastHTML(hdrs=newhdrs, live=True, exts='ws', routes=mount_routes)
    # app.add_middleware(SessionSyncMiddleware)
    rt = app.route
    return app, rt

app, rt = create_app()

# %% ../nbs/00_core.ipynb 7
@rt
def index(request:Request):

    # listteam_comp = Container(Div('Team'), hx_get=f'/portal/list_team', hx_target='#listteam', id='listteam', hx_swap='innerHTML',hx_vals=json.dumps({"folder": str(config.NBPATH)}),  hx_trigger='load')
    comp = Div("Obsidian Companion")
    
    return ifhtmx(request, comp)

# %% ../nbs/00_core.ipynb 9
@rt
def edit(request:Request, session):
    obsidian_url = session['obsidian_url']
    resp = Response(status_code=200)
    # print(url)
    resp.headers["HX-Redirect"] = obsidian_url
    return resp
    

# %% ../nbs/00_core.ipynb 10
@rt
def open(request: Request, session, file: str = "", title: Optional[str]=None):
    # VIDEO_EXTS = (".mp4", ".webm", ".ogg", ".mov", ".mkv")
    # AUDIO_EXTS = (".mp3", ".wav", ".ogg", ".m4a", ".flac")
    # IMAGE_EXTS = (".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp")
    # TEXTLIKE_EXTS = (".md", ".qmd", ".canvas", ".base")
    
    # Simple check: if it's HTMX, return HTML; otherwise return raw file
    is_htmx = request.headers.get('HX-Request')
    
    store = DBStore(config) if config.ENABLE_DB_MODE else FileStore(config)
    out = store.query_file(file)
    if out['content'] is None: return Div(f"Path not found: {urllib.parse.unquote(file)}")

    # If it's a directory â†’ list contents
    if out['is_folder']:
        items = []
        for p in out['content']:
            name = p['fname']
            href = p['url']
            items.append(Li(A(name, href=href)))
        return ifhtmx(request,
            Div(
                f"Listing for {out['title']}:",
                Ul(*items)
            )
        )
    elif out['response_type'] == ResponseTypes.html:
        html = out['content']
        session['obsidian_url'] = out['obsidian_url']

        return ifhtmx(
            request,
            Container(
                H1(out['title'], cls='uk-h1 text-4xl font-bold mt-12 mb-6'),
                Card(NotStr(apply_classes(html)))
            )
        )
    elif out['response_type'] == ResponseTypes.file:
        file = out['content']
        return FileResponse(file)
    elif out['response_type'] == ResponseTypes.blob:
        blob_data = out['content']
        if not isinstance(blob_data, (bytes, bytearray)):
            blob_data = bytes(blob_data)

        mime_type = guess_mime(f"file.{out['extension']}") or "application/octet-stream"
        extension = out['extension'].lower()
        
        # If not HTMX, return raw file
        if not is_htmx:
            return StreamingResponse(
                BytesIO(blob_data),
                media_type=mime_type,
                headers={
                    "Content-Disposition": f'inline; filename="{(title or "file")}.{extension.lstrip(".")}"',
                    "Cache-Control": "no-store",
                }
            )
        
        # For HTMX requests, embed as base64 data URLs
        import base64
        b64_data = base64.b64encode(blob_data).decode('utf-8')
        data_url = f"data:{mime_type};base64,{b64_data}"
        
        # Check file type and return appropriate HTML
        if extension in ExtensionTypes.IMAGE_EXTS:
            return ifhtmx(
                request,
                Container(
                    H1(out['title'] or title or "Image", cls='uk-h1 text-4xl font-bold mt-12 mb-6'),
                    Card(
                        Img(src=data_url, alt=out['title'] or title or "Image", 
                            style="max-width: 100%; height: auto;",
                            cls="uk-responsive-width")
                    )
                )
            )
        elif extension in ExtensionTypes.VIDEO_EXTS:
            return ifhtmx(
                request,
                Container(
                    H1(out['title'] or title or "Video", cls='uk-h1 text-4xl font-bold mt-12 mb-6'),
                    Card(
                        Video(
                            src=data_url,
                            controls=True,
                            style="max-width: 100%; height: auto;"
                        )
                    )
                )
            )
        elif extension in ExtensionTypes.AUDIO_EXTS:
            return ifhtmx(
                request,
                Container(
                    H1(out['title'] or title or "Audio", cls='uk-h1 text-4xl font-bold mt-12 mb-6'),
                    Card(
                        Audio(
                            src=data_url,
                            controls=True
                        )
                    )
                )
            )
        else:
            # For other file types, return as download/stream
            return StreamingResponse(
                BytesIO(blob_data),
                media_type=mime_type,
                headers={
                    "Content-Disposition": f'inline; filename="{(title or "file")}.{extension.lstrip(".")}"',
                    "Cache-Control": "no-store",
                }
            )
    else:
        return ifhtmx(request, Div("No Response"))

# %% ../nbs/00_core.ipynb 11
def iter_file(path, chunk_size=8192):
    with open(path, "rb") as f:
        while chunk := f.read(chunk_size):
            yield chunk

# %% ../nbs/00_core.ipynb 13
def CollapsibleBlocks(title, comp):
    return Div(
            Input(type='checkbox'),
            Div(title, cls='collapse-title font-semibold'),
            Div(comp, cls='collapse-content text-sm'),
            cls='collapse collapse-plus border'
        )

# %% ../nbs/00_core.ipynb 15
@rt
def embed(request: Request, file: str = "", ext: Optional[str] = None, title: Optional[str] = None):
    # VIDEO_EXTS = {".mp4", ".webm", ".ogg", ".mov", ".mkv"}
    # AUDIO_EXTS = {".mp3", ".wav", ".ogg", ".m4a", ".flac"}
    # IMAGE_EXTS = {".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"}
    # TEXTLIKE_EXTS = {".md", ".qmd", ".canvas", ".base"}

    store = DBStore(config) if config.ENABLE_DB_MODE else FileStore(config)
    out = store.query_file(file)
    if out["content"] is None: return Div(f"Path not found: {urllib.parse.unquote(file)}")
    if out["is_folder"]:
            items = []
            for p in out["content"]:
                name = p["fname"]
                href = p["url"]
                items.append(Li(A(name, href=href)))
            return ifhtmx(request, Div(f"Listing for {out['title']}:", Ul(*items)))
    if ext in ExtensionTypes.IMAGE_EXTS:
            headers = {"Content-Type": f"image/{ext.lstrip('.')}"}
            if title: headers["X-Image-Title"] = title
            alt_text = pathlib.Path(file).stem
            headers["X-Image-Alt"] = alt_text
            if out["response_type"] == ResponseTypes.file: return FileResponse(out["content"], headers=headers)
            elif out["response_type"] == ResponseTypes.blob: return StreamingResponse(BytesIO(out["content"]), headers=headers)

    if ext in ExtensionTypes.VIDEO_EXTS:
            mime = guess_mime(file) or f"video/{ext.lstrip('.')}"
            headers = {"Accept-Ranges": "bytes"}
            if out["response_type"] == ResponseTypes.file: return FileResponse(out["content"], media_type=mime, headers=headers, filename=title or file)
            elif out["response_type"] == ResponseTypes.blob: return StreamingResponse(BytesIO(out["content"]), media_type=mime, headers=headers)

        # --- Audio files ---
    if ext in ExtensionTypes.AUDIO_EXTS:
        mime = guess_mime(file) or f"audio/{ext.lstrip('.')}"
        headers = {"Accept-Ranges": "bytes"}
        if out["response_type"] == ResponseTypes.file: return FileResponse(out["content"], media_type=mime, headers=headers, filename=title or file)
        elif out["response_type"] == ResponseTypes.blob: return StreamingResponse(BytesIO(out["content"]), media_type=mime, headers=headers)

    if out["response_type"] == ResponseTypes.html:
        return CollapsibleBlocks(
            Div(out['title']),
            NotStr(apply_classes(out["content"])),
        )

    return ifhtmx(request, Div("Unsupported file type"))
