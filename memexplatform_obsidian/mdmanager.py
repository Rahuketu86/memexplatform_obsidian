"""Obsidian App Compatible Markdown reader"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_mdmanager.ipynb.

# %% auto 0
__all__ = ['config', 'get_subdirs', 'WikiLink', 'AnyLink', 'Properties', 'TagLink', 'Frontmatter', 'ObsidianAstRenderer',
           'ObsidianHTMLRenderer', 'get_obsidianmd_ast', 'print_ast']

# %% ../nbs/05_mdmanager.ipynb 3
from .settings import ObsidianConfig
from enum import Enum
import urllib
import mistletoe
from pathlib import Path
from mistletoe.ast_renderer import ASTRenderer
from mistletoe import Document
import yaml
import re
from typing import List
from mistletoe.block_token import BlockToken
from mistletoe import Document, HTMLRenderer
from mistletoe.ast_renderer import AstRenderer
from mistletoe import span_token, block_token, token
from mistletoe.span_token import Link, RawText, EscapeSequence, AutoLink
from mistletoe.span_tokenizer import tokenize
from mistletoe.token import Token


# %% ../nbs/05_mdmanager.ipynb 5
config = ObsidianConfig(); config
# (config.PORTAL/'index.qmd').exists()

# %% ../nbs/05_mdmanager.ipynb 6
def get_subdirs(vault: Path):
    subdirs = []
    for p in vault.rglob("*"):
        if p.is_dir():
            # Check if any parent directory (including self) should be skipped
            if any(part.startswith((".", "_")) or part.startswith("logseq") for part in p.parts): continue
            subdirs.append(p)
    return subdirs

# %% ../nbs/05_mdmanager.ipynb 10
class WikiLink(Link):
    """
    Obsidian-style wikilink [[Note|Alias]] that behaves like mistletoe.Link.
    """
    pattern = re.compile(r"\[\[([^\]|]+)(?:\|([^\]]+))?\]\]")
    parse_inner = False
    parse_group = 0

    def __init__(self, match):
        # The "target" (like a URL)
        self.target = EscapeSequence.strip(match.group(1).strip())
        # Use alias if present, otherwise same as target
        self.alias = match.group(2) or self.target

        # Fill in Link attributes
        self.title = ""     # Obsidian links don’t have a title
        self.label = None   # No label
        self.dest_type = "wikilink"
        self.title_delimiter = None

        # children: inline text tokens for the alias (like how Link holds link text)
        self.children = [RawText(self.alias)]

# %% ../nbs/05_mdmanager.ipynb 11
class AnyLink(span_token.SpanToken):
    # Match any URI scheme NOT inside markdown link syntax [text](...)
    pattern = re.compile(
        r'(?<!\])([a-zA-Z][a-zA-Z0-9+.-]*://[^\s]+|\[\[.*?\]\])'
    )

    def __init__(self, match):
        content = match.group(1)  # capture group 1 excludes the negative lookbehind
        self.children = (RawText(content),)
        self.target = content
        self.title = "" 

# %% ../nbs/05_mdmanager.ipynb 12
# class Properties(Token):

#     repr_attributes = ("key", "children")
#     def __init__(self, key, value_tokens):
#         self.key = key

#         # Normalize: ensure value_tokens is a flat list of Token objects
#         if isinstance(value_tokens, list):
#             flat = []
#             for v in value_tokens:
#                 if isinstance(v, list):
#                     flat.extend(v)  # flatten nested list
#                 else:
#                     flat.append(v)
#             self.children = flat
#         else:
#             self.children = [value_tokens]

class Properties(Token):
    repr_attributes = ("key", "children")

    def __init__(self, key, value):
        self.key = key
        # Parse value recursively into proper span tokens
        self.children = self._parse_value(value)

    def _parse_value(self, value):
        """Recursively parse value into a flat list of span tokens."""
        if isinstance(value, str):
            stripped = value.strip()
            # Detect plain URLs and convert to AutoLink
            m = AnyLink.pattern.match(stripped)
            if m: return [AnyLink(m)]

            # Otherwise parse as regular inline markdown
            return span_token.tokenize_inner(stripped)
            # return span_token.tokenize_inner(value)

        elif isinstance(value, list):
            tokens = []
            for v in value:
                tokens.extend(self._parse_value(v))
            return tokens

        elif isinstance(value, dict):
            tokens = []
            for k, v in value.items():
                tokens.extend(self._parse_value(v))
            return tokens

        else:
            # Fallback for non-string values
            return [RawText(str(value))]

# %% ../nbs/05_mdmanager.ipynb 13
# def parse_wikilinks(obj):
#     if isinstance(obj, str):
#         # Tokenize inline content using WikiLink
#         tokens = tokenize(obj, (WikiLink,))
#         # If only one token, return it; else return list
#         return tokens[0] if len(tokens) == 1 else tokens
#     elif isinstance(obj, list):
#         return [parse_wikilinks(x) for x in obj]
#     elif isinstance(obj, dict):
#         return {k: parse_wikilinks(v) for k, v in obj.items()}
#     else:
#         return obj

class TagLink(span_token.SpanToken):
    """
    Custom span token for Obsidian-style tags that behaves like a Link.
    This is only used internally and should not be registered as a span token.
    """
    # Add a pattern that will never match anything
    pattern = re.compile(r'(?!.*)')  # Negative lookahead that never matches
    parse_inner = False
    
    def __init__(self, tag_text):
        self.target = "#" + str(tag_text)
        self.title = ""
        self.children = [RawText("#" + str(tag_text))] if tag_text else None

# def parse_markdown_inline(text: str):
#     """Parse a string as inline markdown, returning span tokens."""
#     stripped = text.strip()

#     # Match any URI scheme (http(s), obsidian://, logseq://, etc.)
#     if re.match(r'^[a-zA-Z][a-zA-Z0-9+.-]*://\S+', stripped):
#         return AutoLink(stripped)

#     # Otherwise fall back to inline markdown parsing
#     return span_token.tokenize_inner(stripped)


# def parse_markdown_inline(text):
#     """Parse a string as inline markdown, returning span tokens."""
#     stripped = text.strip()

#     # Match any URI scheme (http(s), obsidian://, logseq://, etc.)
#     match = AutoLink.pattern.match(stripped)
#     if match:
#         return AutoLink(match)  # ✅ pass match, not string

#     # Otherwise fall back to inline markdown parsing
#     return span_token.tokenize_inner(stripped)

# def parse_inline_value(value):
#     """Parse values recursively, treating strings as markdown."""
#     if isinstance(value, str):
#         # Parse string as inline markdown (will include WikiLinks and other span tokens)
#         return parse_markdown_inline(value)
#     elif isinstance(value, list):
#         return [parse_inline_value(v) for v in value]
#     elif isinstance(value, dict):
#         return {k: parse_inline_value(v) for k, v in value.items()}
#     else:
#         return RawText(str(value))
        
class Frontmatter(BlockToken):
    """
    YAML Frontmatter token.
    This is a leaf block token that captures metadata enclosed by --- ... ---.
    """

    repr_attributes = BlockToken.repr_attributes + ("data",)

    # Match `---` followed by anything until the next `---` on its own line
    pattern = re.compile(
        r'(?ms)^(?:---)\s*\n(.*?)(?:\n---\s*$)'
    )

    def __init__(self, content: str):
        self.content = content.strip()
        try:
            self.data = yaml.safe_load(self.content) or {}
        except yaml.YAMLError as e:
            self.data = {"error": str(e)}
        
        # Process the YAML data into children, parsing each value as markdown
        self.children = []
        
        self.children = []

        for k, v in self.data.items():
            self.children.append(Properties(k, v))
            # if k == "tags":
            #     tags = v if isinstance(v, list) else [v]
            #     tokenized = [
            #         TagLink(tag) if isinstance(tag, str) else parse_inline_value(tag)
            #         for tag in tags
            #     ]
            #     self.children.append(Properties(k, tokenized))
            # else:
            #     # parsed_value = parse_inline_value(v)
            #     self.children.append(Properties(k, v))

    @classmethod
    def start(cls, line: str) -> bool:
        # Only starts if line is `---`
        return line.strip() == "---"

    @classmethod
    def check_interrupts_paragraph(cls, lines):
        return cls.start(lines.peek())

    @classmethod
    def read(cls, lines):
        # Consume first line (`---`)
        next(lines)
        buffer = []
        for line in lines:
            if line.strip() == "---":
                break
            buffer.append(line)
        return "".join(buffer)

# %% ../nbs/05_mdmanager.ipynb 14
class ObsidianAstRenderer(AstRenderer):
    def __init__(self,  **kwargs):
        super().__init__(Frontmatter, WikiLink, TagLink, AnyLink,  **kwargs)  # register custom token
    
    def render_wiki_link(self, token):
        return self.render_link(token)

    def render_any_link(self, token):
        return self.render_link(token)

    def render_tag_link(self, token):
        return token.children
    
    def render_frontmatter(self, token: Frontmatter) -> dict:
        # Just return dict so AST expansion shows structured metadata
        return token.children

# %% ../nbs/05_mdmanager.ipynb 15
class ObsidianHTMLRenderer(HTMLRenderer):
    def __init__(self, **kwargs):
        super().__init__(Frontmatter, WikiLink, TagLink, AnyLink, **kwargs)  # register custom tokens
    
    def render_wiki_link(self, token):
        return self.render_link(token)

    def render_any_link(self, token):
        return self.render_link(token)
    
    def render_tag_link(self, token):
        """Render TagLink as a span with tag styling."""
        return f'<span class="tag">{self.render_inner(token)}</span>'

    def render_frontmatter(self, token: Frontmatter) -> str:
        if not token.children:
            return '<div class="frontmatter"></div>'

        rows = []
        for prop in token.children:  # each is a Properties token
            key_html = f"<th>{prop.key}</th>"
            value_html = "".join(self.render(child) for child in prop.children)
            rows.append(f"<tr>{key_html}<td>{value_html}</td></tr>")

        return (
            '<div class="frontmatter">\n'
            '<table>\n'
            + "\n".join(rows)
            + "\n</table>\n</div>"
        )

# %% ../nbs/05_mdmanager.ipynb 17
def get_obsidianmd_ast(text):
    span_token.add_token(WikiLink)
    block_token.add_token(Frontmatter)
    span_token.add_token(TagLink)
    return Document(text)

# %% ../nbs/05_mdmanager.ipynb 22
def print_ast(token, indent=0):
    pad = "  " * indent
    data = {k: v for k, v in getattr(token, "__dict__", {}).items() if not k.startswith("_")}
    print(f"{pad}{token.__class__.__name__}: {data}")
    
    # Safely iterate over children if present and iterable
    children = getattr(token, "children", None)
    if children:
        for child in children:
            print_ast(child, indent + 1)
