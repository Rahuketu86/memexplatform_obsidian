"""Obsidian App Compatible Markdown reader"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_mdmanager.ipynb.

# %% auto 0
__all__ = ['config', 'CALLOUT_TYPE_MAP', 'CALLOUT_BLOCK_REGEX', 'CALLOUT_FIRST_LINE_REGEX', 'get_subdirs', 'resolve_note_path',
           'ObsidianEmbed', 'ObsidianLink', 'WikiLink', 'AnyLink', 'Properties', 'TagLink', 'Frontmatter',
           'ObsidianCallout', 'ObsidianAstRenderer', 'ObsidianHTMLRenderer', 'ObsidianPage', 'get_obsidianmd_ast',
           'print_ast', 'get_frontmatter', 'get_property', 'get_title']

# %% ../nbs/05_mdmanager.ipynb 3
from .settings import ObsidianConfig
from enum import Enum
import urllib
import mistletoe
from pathlib import Path
from mistletoe.ast_renderer import ASTRenderer
from mistletoe import Document
import yaml
import re
from typing import List
from mistletoe.block_token import BlockToken, Quote
from mistletoe import Document, HTMLRenderer
from mistletoe.ast_renderer import AstRenderer
from mistletoe import span_token, block_token, token
from mistletoe.span_token import Link, RawText, EscapeSequence, AutoLink
from mistletoe.span_tokenizer import tokenize
from mistletoe.token import Token
from .commons import MountPaths
from mistletoe.block_tokenizer import tokenize_block
import pathlib
import mimetypes
from typing import Optional
from datetime import datetime, timezone
# from fasthtml.common import *
# from monsterui.all import *



# %% ../nbs/05_mdmanager.ipynb 5
config = ObsidianConfig(); config
# (config.PORTAL/'index.qmd').exists()

# %% ../nbs/05_mdmanager.ipynb 6
def get_subdirs(vault: Path):
    subdirs = []
    for p in vault.rglob("*"):
        if p.is_dir():
            # Check if any parent directory (including self) should be skipped
            if any(part.startswith((".", "_")) or part.startswith("logseq") for part in p.parts): continue
            subdirs.append(p)
    return subdirs

# %% ../nbs/05_mdmanager.ipynb 7
def resolve_note_path(vault:Path, file:str) -> Path | None:
    search_term = urllib.parse.unquote(file); search_term
    rel_path = Path(search_term); rel_path
    fname = rel_path.name
    fldr = rel_path.parent; fldr
    pfname = None
    extensions = ('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.svg', '.webp', '.tiff', '.ico',
                    '.base', '.canvas', '.md', '.qmd', '.ipynb'
                )
    if fldr.name == "":
        if fname.lower().endswith(extensions):
            for sub in get_subdirs(vault):
                pfname = next(sub.rglob(fname), None)
                if pfname: break
        else:
            mdfname = fname +".md"
            for sub in get_subdirs(vault):
                pfname = next(sub.rglob(mdfname), None)
                if pfname: break
    else:
        if fname.lower().endswith(extensions):
            pfname = next((vault/fldr).rglob(fname), None)
        else:
            mdfname = fname +".md"
            pfname = next((vault/fldr).rglob(mdfname), None)
    if pfname: return pfname
    else: 
        lsfldr = vault/search_term
        if lsfldr.is_dir(): return lsfldr
        else: return None

# %% ../nbs/05_mdmanager.ipynb 11
class ObsidianEmbed(Link):
    """
    Obsidian-style embeds:
      - ![[Note]]        → embed note or image
      - ![alt](target)   → embed note or image
      - ![alt](target "title") → embed with title

    Behavior:
      - If target ends with .md / .qmd / .canvas / .base → inline blockquote of rendered content
      - If target ends with image extension → inline <img>
      - Otherwise → fallback to simple link
    """

    # ![[Note|Alias]] OR ![alt](target "title")
    pattern = re.compile(
        r'!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]'         # ![[Note|Alias]]
        r'|!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)'  # ![alt](target "title")
    )
    parse_inner = False
    parse_group = 0
    repr_attributes = ("ext", "fname", "children", "title", "label", "dest_type", "title_delimiter", "label", "src")

    def __init__(self, match):
        if match.group(1):  # ![[Note|Alias]]
            raw_target = EscapeSequence.strip(match.group(1).strip())
            alias = match.group(2) or raw_target
            title = ""
        else:  # ![alt](target "title")
            alias = match.group(3) or ""
            raw_target = EscapeSequence.strip(urllib.parse.unquote(match.group(4).strip()))
            title = match.group(5) or ""

        self.title = title
        if raw_target.startswith(("http://", "https://")):
            self.target = raw_target
            self.fname = None
            self.ext = None
            self.src = raw_target
        else:
            self.fname = raw_target
            self.ext = pathlib.Path(raw_target).suffix or ".md"
            self.target = MountPaths.embed.to(file=raw_target, ext=self.ext, title=self.title)
            self.src = self.target

        self.label = None
        self.dest_type = "obsidianembed"
        self.title_delimiter = None

        # Render children as the alias text
        self.children = list(span_token.tokenize_inner(alias))

# %% ../nbs/05_mdmanager.ipynb 12
class ObsidianLink(Link):
    """
    Obsidian-style markdown link [Alias](target "title").
    - If target is an http(s) URL, render as normal.
    - Otherwise, rewrite to open?file=<escaped target>.
    """

    # Matches [Alias](target "title")
    pattern = re.compile(r'\[([^\]]+)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)')
    parse_inner = False
    parse_group = 0

    repr_attributes = ("ext", "fname", "children", "title", "label", "dest_type", "title_delimiter", "label", "src")

    def __init__(self, match):
        alias = match.group(1).strip()
        raw_target = EscapeSequence.strip(urllib.parse.unquote(match.group(2).strip()))
        title = match.group(3) or ""

        self.title = title
        if raw_target.startswith(("http://", "https://")):
            self.target = raw_target
            self.fname = None
            self.ext = None
            self.src = raw_target
        else:
            self.fname = raw_target
            self.ext = pathlib.Path(raw_target).suffix or ".md"
            self.target = MountPaths.open.to(file=raw_target, title=self.title)
            self.src = self.target

        
        self.label = None
        self.dest_type = "obsidianlink"
        self.title_delimiter = None
        # self.children = [RawText(alias)]
        self.children = list(span_token.tokenize_inner(alias))


# %% ../nbs/05_mdmanager.ipynb 13
class WikiLink(Link):
    """
    Obsidian-style wikilink [[Note|Alias]] that behaves like mistletoe.Link.
    """
    pattern = re.compile(r"\[\[([^\]|]+)(?:\|([^\]]+))?\]\]")
    parse_inner = False
    parse_group = 0
    repr_attributes = ("ext", "fname", "children", "title", "label", "dest_type", "title_delimiter", "label", "src")

    def __init__(self, match):
        # The "target" (like a URL)
        raw_target = EscapeSequence.strip(match.group(1).strip())
        self.target = MountPaths.open.to(file=raw_target)
        # Use alias if present, otherwise same as target
        self.alias = match.group(2) or raw_target
        self.fname = raw_target
        self.ext = pathlib.Path(raw_target).suffix or ".md"
        self.src = self.target

        # Fill in Link attributes
        self.title = ""     # Obsidian links don’t have a title
        self.label = None   # No label
        self.dest_type = "wikilink"
        self.title_delimiter = None

        # children: inline text tokens for the alias (like how Link holds link text)
        # self.children = [RawText(self.alias)]
        self.children = list(span_token.tokenize_inner(self.alias))

# %% ../nbs/05_mdmanager.ipynb 14
class AnyLink(span_token.SpanToken):
    """
    Match any URI scheme like obsidian://, logseq://, code://, http://, https:// etc.
    Does NOT match markdown links [text](...) or wikilinks [[Note]].
    """
    # Must capture the whole URL in group 1
    pattern = re.compile(r'(?<![\]\)"])(([a-zA-Z][a-zA-Z0-9+.-]*://[^\s]+))')
    parse_group = 1

    def __init__(self, match):
        url = match.group(1)
        self.children = (RawText(url),)
        self.target = url
        self.title = ""

# %% ../nbs/05_mdmanager.ipynb 15
class Properties(Token):
    repr_attributes = ("key", "children")

    def __init__(self, key, value):
        self.key = key
        # Parse value recursively into proper span tokens
        self.children = self._parse_value(value)

    def _parse_value(self, value):
        """Recursively parse value into a flat list of span tokens."""
        if isinstance(value, str):
            stripped = value.strip()
            # Detect plain URLs and convert to AutoLink
            m = AnyLink.pattern.match(stripped)
            if m: return [AnyLink(m)]

            # Otherwise parse as regular inline markdown
            return span_token.tokenize_inner(stripped)
            # return span_token.tokenize_inner(value)

        elif isinstance(value, list):
            tokens = []
            for v in value:
                tokens.extend(self._parse_value(v))
            return tokens

        elif isinstance(value, dict):
            tokens = []
            for k, v in value.items():
                tokens.extend(self._parse_value(v))
            return tokens

        else:
            # Fallback for non-string values
            return [RawText(str(value))]

# %% ../nbs/05_mdmanager.ipynb 16
class TagLink(Link):
    """
    Obsidian-style tag link #tag that behaves like a mistletoe.Link.
    Renders to <a href="/tags/tag">#tag</a> or similar.
    """
    # Matches hashtags at word boundaries: # followed by word characters/dashes
    pattern = re.compile(r'(?<!\w)#([\w\-]+)')
    parse_group = 0
    parse_inner = False

    def __init__(self, match):
        tag_name = match.group(1)

        # URL target (you can change the prefix to match your app)
        self.target = MountPaths.tag.to(tag=tag_name)
        self.title = ""
        self.label = None
        self.dest_type = "taglink"
        self.title_delimiter = None

        # Displayed text is "#tag"
        self.children = [RawText(f"#{tag_name}")]

# %% ../nbs/05_mdmanager.ipynb 17
class Frontmatter(BlockToken):
    """
    YAML Frontmatter token.
    This is a leaf block token that captures metadata enclosed by --- ... ---.
    """

    repr_attributes = BlockToken.repr_attributes + ("data",)

    # Match `---` followed by anything until the next `---` on its own line
    # pattern = re.compile(
    #     r'(?ms)^(?:---)\s*\n(.*?)(?:\n---\s*$)'
    # )

    pattern = re.compile(
        r'(?ms)\A---\s*\n(.*?)(?:\n---\s*\n)'
    )

    def __init__(self, content: str):
        self.content = content.strip()
        try:
            parsed = yaml.safe_load(self.content) or {}
        except yaml.YAMLError as e:
            parsed = {"error": str(e)}


        if isinstance(parsed, dict):
            self.data = parsed
        else:
            # wrap scalars/lists into a dict
            self.data = {"value": parsed}
        
        # Process the YAML data into children, parsing each value as markdown
        self.children = []
        
        for k, v in self.data.items():
            if k.lower() == "tags":
                tags = v if isinstance(v, list) else [v]
                            # Prepend "#" so later inline parsing makes TagLinks
                processed = [f"#{t}" for t in tags if isinstance(t, str)]
                self.children.append(Properties(k, processed))
            else: self.children.append(Properties(k, v))

    @classmethod
    def start(cls, line: str) -> bool:
        # Only starts if line is `---`
        return line.strip() == "---"

    @classmethod
    def check_interrupts_paragraph(cls, lines):
        return cls.start(lines.peek())

    @classmethod
    def read(cls, lines):
        if lines.line_number() > 1:
            return None 
        # Consume first line (`---`)
        next(lines)
        buffer = []
        for line in lines:
            if line.strip() == "---":
                break
            buffer.append(line)
        return "".join(buffer)

# %% ../nbs/05_mdmanager.ipynb 18
CALLOUT_TYPE_MAP = {
    'info': 'info', 'tip': 'tip', 'warning': 'warning',
    'caution': 'warning', 'danger': 'danger', 'error': 'danger',
    'success': 'success', 'note': 'note', 'abstract': 'abstract',
    'todo': 'todo', 'question': 'question', 'help': 'question',
    'example': 'example', 'quote': 'quote', 'bug': 'bug', 'failure': 'failure',
}

# Updated regexes

# Full block: marker line + at least one more >-line:
CALLOUT_BLOCK_REGEX = re.compile(
    r'(?ms)\A'                                         # start
    r'>\s*\[!([A-Za-z0-9_-]+)\]([+-]?)(?:\s*(.*?))?'    # capture type, optional fold-flag, optional title (non-greedy)
    r'(?:\r?\n>.*)+'                                   # body: one or more quoted lines
)

# First line only, for start detection
CALLOUT_FIRST_LINE_REGEX = re.compile(
    r'^\s*>\s*\[!([A-Za-z0-9_-]+)\]([+-]?)(?:\s*(.*?))?$'
)

class ObsidianCallout(Quote):

    @staticmethod
    def start(line: str) -> bool:
        return bool(CALLOUT_FIRST_LINE_REGEX.match(line))

    @classmethod
    def read(cls, lines):
        raw_buffer = []
        start_line_number = lines.line_number()
        try:
            first_line = next(lines)
        except StopIteration:
            return None
        raw_buffer.append(first_line)

        for nl in lines:
            if nl.lstrip().startswith('>'):
                raw_buffer.append(nl)
            else:
                break

        joined = ''.join(raw_buffer)
        m = CALLOUT_BLOCK_REGEX.match(joined)
        if not m:
            return None

        raw_type = m.group(1)
        fold_flag = m.group(2) or ''
        title = (m.group(3) or '').strip()
        canonical = CALLOUT_TYPE_MAP.get(raw_type.lower(), 'note')

        # Extract content lines, clean them properly
        raw_lines = joined.splitlines()[1:]  # Skip header line
        body_lines = []

        for raw in raw_lines:
            stripped = raw.lstrip()
            if stripped.startswith('>'):
                content = stripped[1:].lstrip()  # Remove '>' and leading space
                if content:
                    # Each line as a separate paragraph with final newline
                    body_lines.append(content + '\n\n')

        # Tokenize block
        parse_buffer = tokenize_block(
            body_lines, block_token._token_types, start_line=start_line_number + 1
        )

        return (parse_buffer, canonical, fold_flag, title)

    def __init__(self, read_result):
        parse_buffer, canonical_type, fold_flag, title = read_result
        super().__init__(parse_buffer)
        self.is_callout = True
        self.callout_type = canonical_type
        self.fold_flag = fold_flag
        self.callout_title = title or canonical_type.capitalize()


# %% ../nbs/05_mdmanager.ipynb 19
class ObsidianAstRenderer(AstRenderer):
    def __init__(self,  **kwargs):
        super().__init__(Frontmatter, WikiLink, TagLink, AnyLink, ObsidianLink, ObsidianEmbed, ObsidianCallout, **kwargs)  # register custom token

    def render_obsidian_embed(self, token):
        return self.render_link(token)
    
    def render_obsidian_link(self, token):
        return self.render_link(token)

    def render_wiki_link(self, token):
        return self.render_link(token)

    def render_any_link(self, token):
        return self.render_link(token)

    def render_tag_link(self, token):
        return self.render_link(token)
    
    def render_obsidian_callout(self, token: ObsidianCallout):
        return self.render_quote(token)
    
    def render_frontmatter(self, token: Frontmatter) -> dict:
        # Just return dict so AST expansion shows structured metadata
        return token.children

# %% ../nbs/05_mdmanager.ipynb 20
class ObsidianHTMLRenderer(HTMLRenderer):

    VIDEO_EXTS = {".mp4", ".webm", ".ogg", ".mov", ".mkv"}
    AUDIO_EXTS = {".mp3", ".wav", ".ogg", ".m4a", ".flac"}
    IMAGE_EXTS = {".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"}
    TEXTLIKE_EXTS = {".md", ".qmd", ".canvas", ".base"}

    def __init__(self, **kwargs):
        super().__init__(Frontmatter, WikiLink, TagLink, AnyLink, ObsidianLink, ObsidianEmbed, ObsidianCallout,  **kwargs)  # register custom tokens

    def render_obsidian_embed(self, token):
        target = token.target
        ext = token.ext
        fname = token.fname
        src = token.src
        alt = token.title or "" or (token.children[0].content if token.children else "")
        if ext in self.IMAGE_EXTS: return self.render_image(token)
        if ext in self.TEXTLIKE_EXTS: 
    
            # return f'<blockquote data-embed="{src}">{alt}</blockquote>'
            return (
            f'<blockquote class="note-embed-placeholder" '
            f'data-embed-url="{src}" '
            f'hx-get="{src}" '
            f'hx-trigger="revealed once" '
            f'hx-swap="outerHTML">'
            f'Loading {alt}…'
            f'</blockquote>'
        )
        if ext in self.AUDIO_EXTS:
            mimetypes.guess_type
            # mime = f"audio/{ext[1:]}" if ext else "audio/mpeg"
            mime = mimetypes.guess_type(fname, strict=False)[0]
            return f'<audio controls><source src="{src}" type="{mime}">Your browser does not support the audio tag.</audio>'
        if ext in self.VIDEO_EXTS or "youtube.com" in src or "youtu.be" in src or "vimeo.com" in src:
            if "youtube.com/watch" in src or "youtu.be/" in src:
                parsed = urllib.parse.urlparse(src)
                qs = urllib.parse.parse_qs(parsed.query)
                vid = qs.get("v", [""])[0] if "v" in qs else parsed.path.split("/")[-1]
                return f'<iframe width="560" height="315" src="https://www.youtube.com/embed/{vid}" frameborder="0" allowfullscreen></iframe>'
            if "vimeo.com" in src:
                vid = src.rstrip("/").split("/")[-1]
                return f'<iframe src="https://player.vimeo.com/video/{vid}" width="640" height="360" frameborder="0" allowfullscreen></iframe>'
            # mime = f"video/{ext[1:]}" if ext else "video/mp4"
            mime = mimetypes.guess_type(fname, strict=False)[0]
            return f'<video controls><source src="{src}" type="{mime}">Your browser does not support the video tag.</video>'
        return self.render_link(token)
    
    def render_obsidian_link(self, token):
        return self.render_link(token)
        
    def render_wiki_link(self, token):
        return self.render_link(token)

    def render_any_link(self, token):
        return self.render_link(token)
    
    def render_tag_link(self, token):
        """Render TagLink as a span with tag styling."""
        return self.render_link(token)

    def render_frontmatter(self, token: Frontmatter) -> str:
        if not token.children:
            return '<div class="frontmatter"></div>'

        rows = []
        for prop in token.children:  # each is a Properties token
            key_html = f"<th>{prop.key}</th>"
            value_html = ", ".join(self.render(child) for child in prop.children)
            rows.append(f"<tr>{key_html}<td>{value_html}</td></tr>")

        return (
            '<div class="frontmatter">\n'
            '<table>\n'
            + "\n".join(rows)
            + "\n</table>\n</div>"
        )

    def render_obsidian_callout(self, token: ObsidianCallout):
        if isinstance(token, ObsidianCallout) and getattr(token, 'is_callout', False):
            type_cls = token.callout_type or "note"  # fallback type
            collapsed_by_default = (token.fold_flag == "-")
            title = token.callout_title or type_cls.capitalize()

            # Render body HTML from children with line breaks
            body_html = ""
            # for child in token.children:
            #     print(child)
            #     body_html += f", {child}"
            body_html = "".join(self.render(child) for child in token.children)

            # Collapse container class - using 'plus' instead of type
            collapse_class = "collapse collapse-plus border"

            # Checkbox - no ID needed, just the class
            checked_attr = "" if collapsed_by_default else " checked"

            html = f"""
    <div class="{collapse_class}">
    <input type="checkbox" class="uk-input"{checked_attr}>
    <div class="collapse-title font-semibold">{title}</div>
    <blockquote class="collapse-content text-sm">
    {body_html}
    </blockquote>
    </div>
    """
            return html.strip()
        else:
            return super().render_quote(token)


# %% ../nbs/05_mdmanager.ipynb 23
class ObsidianPage(object):

    VIDEO_EXTS = [".mp4", ".webm", ".ogg", ".mov", ".mkv"]
    AUDIO_EXTS = [".mp3", ".wav", ".ogg", ".m4a", ".flac"]
    IMAGE_EXTS = [".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"]
    TEXTLIKE_EXTS = [".md", ".qmd", ".canvas", ".base", '.ipynb']

    def __init__(self, text, fpath=None):
        self._text = text
        self._fpath = pathlib.Path(fpath)

        s = fpath.stat(); s.st_size
        self.created_time = datetime.fromtimestamp(s.st_ctime_ns / 1e9, tz=timezone.utc)
        # mtime (last modification time in ns)
        self.modified_time = datetime.fromtimestamp(s.st_mtime_ns / 1e9, tz=timezone.utc)
        self.file_size = s.st_size

    
    @property
    def file_extension(self):
        ext = self._fpath.suffix
        if ext in self.VIDEO_EXTS+self.AUDIO_EXTS+self.IMAGE_EXTS+self.TEXTLIKE_EXTS:
            return ext[1:]
        return None

    @classmethod
    def from_file_path(cls, file_path: Path):
        text: str = None
        file_path = pathlib.Path(file_path)
        if not file_path.is_file():
            # Handle cases where the path does not point to a regular file
            if not file_path.exists():
                text = f"[Error: File not found at path: {file_path}]"
            else:  # Path exists but is not a file (e.g., a directory, or a special file)
                text = f"[Error: Path exists but is not a regular file: {file_path}]"
        else:
            try:
                text = file_path.read_text(encoding="utf-8")
            except UnicodeDecodeError:
                text = f"[Error: Unable to decode file content at {file_path}. Please check encoding.]"
            except PermissionError:
                text = f"[Error: Permission denied to read file at {file_path}.]"
            except Exception as e:
                # Catch any other unexpected errors during file reading
                text = f"[Error: An unexpected error occurred while reading {file_path}. Reason: {e}]"
        return cls(text=text, fpath=file_path)


    @property
    def lockey(self):
        return str(self._fpath.relative_to(config.OBSIDIAN_VAULT)) if self._fpath else None

    @property
    def obsidian_url(self):
        return MountPaths.obsidian_url.with_qparams(vault=config.OBSIDIAN_VAULT.name, file=self.lockey)

    @property
    def doc(self):
        span_token.add_token(ObsidianEmbed)
        span_token.add_token(ObsidianLink)
        span_token.add_token(WikiLink)
        block_token.add_token(Frontmatter)
        block_token.add_token(ObsidianCallout)
        span_token.add_token(TagLink)
        return Document(self._text)

    @property
    def frontmatter(self)->Optional[Frontmatter]:
        for o in self.doc.children:
            if type(o).__name__ == 'Frontmatter': return o
        return None

    def get_property(self, key='title'):
        if self.frontmatter:
            for p in self.frontmatter.children:
                if p.key == key: return p
        return None

    @property
    def title(self):
        p = self.get_property('title'); 
        if p:
            o = p.children[0]
            return o.content
        return self._fpath.stem if self._fpath else None

    @property
    def collection(self):
        collection = self.get_property('collection')
        return [str(resolve_note_path(vault=config.OBSIDIAN_VAULT, 
                   file=child.fname).relative_to(config.OBSIDIAN_VAULT))
                   for child in collection.children
                ] if collection else None

    @property
    def html(self):
        with ObsidianHTMLRenderer() as renderer:
            # html = renderer.render(Document(lines))
            html = renderer.render(self.doc)
        return html

    @property
    def ast(self):
        with ObsidianAstRenderer() as renderer:
            # html = renderer.render(Document(lines))
            html = renderer.render(self.doc)
        return html

# %% ../nbs/05_mdmanager.ipynb 25
def get_obsidianmd_ast(text):
    # span_token.add_token(Link)       # [text](url)
    # span_token.add_token(AutoLink)   # <http://example.com>
    span_token.add_token(ObsidianEmbed)
    span_token.add_token(ObsidianLink)
    span_token.add_token(WikiLink)
    block_token.add_token(Frontmatter)
    block_token.add_token(ObsidianCallout)
    span_token.add_token(TagLink)
    return Document(text)

# %% ../nbs/05_mdmanager.ipynb 32
def print_ast(token, indent=0):
    pad = "  " * indent
    data = {k: v for k, v in getattr(token, "__dict__", {}).items() if not k.startswith("_")}
    print(f"{pad}{token.__class__.__name__}: {data}")
    
    # Safely iterate over children if present and iterable
    children = getattr(token, "children", None)
    if children:
        for child in children:
            print_ast(child, indent + 1)

# %% ../nbs/05_mdmanager.ipynb 33
def get_frontmatter(doc):
    for o in doc.children:
        if type(o).__name__ == 'Frontmatter': return o
    return None

# %% ../nbs/05_mdmanager.ipynb 34
def get_property(doc, key='title'):
    fm = get_frontmatter(doc)
    if fm:
        for p in fm.children:
            if p.key ==key: return p
    return None

# %% ../nbs/05_mdmanager.ipynb 35
def get_title(doc):
    p = get_property(doc, key='title'); 
    if p:
        o = p.children[0]
        return o.content
    return None
