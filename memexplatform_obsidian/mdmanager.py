"""Obsidian App Compatible Markdown reader"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_mdmanager.ipynb.

# %% auto 0
__all__ = ['config', 'get_subdirs', 'ObsidianEmbed', 'ObsidianLink', 'WikiLink', 'AnyLink', 'Properties', 'TagLink',
           'Frontmatter', 'ObsidianAstRenderer', 'ObsidianHTMLRenderer', 'get_obsidianmd_ast', 'print_ast',
           'get_frontmatter', 'get_property', 'get_title']

# %% ../nbs/05_mdmanager.ipynb 3
from .settings import ObsidianConfig
from enum import Enum
import urllib
import mistletoe
from pathlib import Path
from mistletoe.ast_renderer import ASTRenderer
from mistletoe import Document
import yaml
import re
from typing import List
from mistletoe.block_token import BlockToken
from mistletoe import Document, HTMLRenderer
from mistletoe.ast_renderer import AstRenderer
from mistletoe import span_token, block_token, token
from mistletoe.span_token import Link, RawText, EscapeSequence, AutoLink
from mistletoe.span_tokenizer import tokenize
from mistletoe.token import Token
from .commons import MountPaths
import pathlib


# %% ../nbs/05_mdmanager.ipynb 5
config = ObsidianConfig(); config
# (config.PORTAL/'index.qmd').exists()

# %% ../nbs/05_mdmanager.ipynb 6
def get_subdirs(vault: Path):
    subdirs = []
    for p in vault.rglob("*"):
        if p.is_dir():
            # Check if any parent directory (including self) should be skipped
            if any(part.startswith((".", "_")) or part.startswith("logseq") for part in p.parts): continue
            subdirs.append(p)
    return subdirs

# %% ../nbs/05_mdmanager.ipynb 11
class ObsidianEmbed(Link):
    """
    Obsidian-style embeds:
      - ![[Note]]        → embed note or image
      - ![alt](target)   → embed note or image
      - ![alt](target "title") → embed with title

    Behavior:
      - If target ends with .md / .qmd / .canvas / .base → inline blockquote of rendered content
      - If target ends with image extension → inline <img>
      - Otherwise → fallback to simple link
    """

    # ![[Note|Alias]] OR ![alt](target "title")
    pattern = re.compile(
        r'!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]'         # ![[Note|Alias]]
        r'|!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)'  # ![alt](target "title")
    )
    parse_inner = False
    parse_group = 0
    repr_attributes = ("ext", "fname", "children", "title", "label", "dest_type", "title_delimiter", "label", "src")

    def __init__(self, match):
        if match.group(1):  # ![[Note|Alias]]
            raw_target = EscapeSequence.strip(match.group(1).strip())
            alias = match.group(2) or raw_target
            title = ""
        else:  # ![alt](target "title")
            alias = match.group(3) or ""
            raw_target = EscapeSequence.strip(urllib.parse.unquote(match.group(4).strip()))
            title = match.group(5) or ""

        self.title = title
        if raw_target.startswith(("http://", "https://")):
            self.target = raw_target
            self.fname = None
            self.ext = None
            self.src = raw_target
        else:
            self.fname = raw_target
            self.ext = pathlib.Path(raw_target).suffix or ".md"
            self.target = MountPaths.embed.to(file=raw_target, ext=self.ext, title=self.title)
            self.src = self.target

        self.label = None
        self.dest_type = "obsidianembed"
        self.title_delimiter = None

        # Render children as the alias text
        self.children = [RawText(alias)]

# class ObsidianEmbed(Link):
#     """
#     Obsidian-style embeds:
#       - ![[Note]]        → embed note or image
#       - ![alt](target)   → embed note or image

#     Behavior:
#       - If target ends with .md / .qmd / .canvas / .base → inline blockquote of rendered content
#       - If target ends with image extension → inline <img>
#       - Otherwise → fallback to simple link
#     """

#     pattern = re.compile(r"!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]|!\[([^\]]*)\]\(([^)]+)\)")
#     parse_inner = False
#     parse_group = 0
#     repr_attributes = ("ext", "fname",  "children", "title", "label", "dest_type", "title_delimiter", "label", "src")
#     # TEXTLIKE_EXTS = {".md", ".qmd", ".canvas", ".base"}
#     # IMGLIKE_EXTS = {".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"}
#     def __init__(self, match):
#       if match.group(1):  # ![[Note|Alias]]
#           raw_target = EscapeSequence.strip(match.group(1).strip())
#           alias = match.group(2) or raw_target
#       else:               # ![alt](target)
#           alias = match.group(3) or ""
#           raw_target = EscapeSequence.strip(urllib.parse.unquote(match.group(4).strip()))

#       if raw_target.startswith(("http://", "https://")): 
#         self.target = raw_target
#         self.fname = None
#         self.ext = None
#         self.src = raw_target
#       else: 
#         self.fname = raw_target
#         self.ext = pathlib.Path(raw_target).suffix if pathlib.Path(raw_target).suffix else ".md"
#         self.target = MountPaths.embed.to(file=raw_target, ext=self.ext)
#         self.src = self.target

#       self.title = ""
#       self.label = None
#       self.dest_type = "obsidianembed"
#       self.title_delimiter = None

#       # Render children as the alias text
#       self.children = [RawText(alias)]

# %% ../nbs/05_mdmanager.ipynb 12
class ObsidianLink(Link):
    """
    Obsidian-style markdown link [Alias](target "title").
    - If target is an http(s) URL, render as normal.
    - Otherwise, rewrite to open?file=<escaped target>.
    """

    # Matches [Alias](target "title")
    pattern = re.compile(r'\[([^\]]+)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)')
    parse_inner = False
    parse_group = 0

    def __init__(self, match):
        alias = match.group(1).strip()
        raw_target = EscapeSequence.strip(urllib.parse.unquote(match.group(2).strip()))
        title = match.group(3) or ""

        self.title = title
        if raw_target.startswith(("http://", "https://")):
            self.target = raw_target
        else:
            self.target = MountPaths.open.to(file=raw_target, title=self.title)

        
        self.label = None
        self.dest_type = "obsidianlink"
        self.title_delimiter = None
        self.children = [RawText(alias)]

# class ObsidianLink(Link):
#     """
#     Obsidian-style markdown link [Alias](target).
#     - If target is an http(s) URL, render as normal.
#     - Otherwise, rewrite to open?file=<escaped target>.
#     """

#     # Matches [Alias](target)
#     pattern = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")
#     parse_inner = False
#     parse_group = 0

#     def __init__(self, match):
#         # Extract alias (visible text) and raw target (destination)
#         alias = match.group(1).strip()
        
#         raw_target = EscapeSequence.strip(urllib.parse.unquote(match.group(2).strip()))

#         # If http/https, keep original target
#         if raw_target.startswith(("http://", "https://")):
#             self.target = raw_target
#         else:
#             # Otherwise, map to "open?file=<quoted target>"
#             self.target = MountPaths.open.to(file=raw_target)

#         # No title attribute by default
#         self.title = ""
#         self.label = None
#         self.dest_type = "obsidianlink"
#         self.title_delimiter = None

#         # Render children as the alias text
#         self.children = [RawText(alias)]

# %% ../nbs/05_mdmanager.ipynb 13
class WikiLink(Link):
    """
    Obsidian-style wikilink [[Note|Alias]] that behaves like mistletoe.Link.
    """
    pattern = re.compile(r"\[\[([^\]|]+)(?:\|([^\]]+))?\]\]")
    parse_inner = False
    parse_group = 0

    def __init__(self, match):
        # The "target" (like a URL)
        raw_target = EscapeSequence.strip(match.group(1).strip())
        self.target = MountPaths.open.to(file=raw_target)
        # Use alias if present, otherwise same as target
        self.alias = match.group(2) or raw_target

        # Fill in Link attributes
        self.title = ""     # Obsidian links don’t have a title
        self.label = None   # No label
        self.dest_type = "wikilink"
        self.title_delimiter = None

        # children: inline text tokens for the alias (like how Link holds link text)
        self.children = [RawText(self.alias)]

# %% ../nbs/05_mdmanager.ipynb 14
class AnyLink(span_token.SpanToken):
    """
    Match any URI scheme like obsidian://, logseq://, code://, http://, https:// etc.
    Does NOT match markdown links [text](...) or wikilinks [[Note]].
    """
    # Must capture the whole URL in group 1
    pattern = re.compile(r'(?<![\]\)"])(([a-zA-Z][a-zA-Z0-9+.-]*://[^\s]+))')
    parse_group = 1

    def __init__(self, match):
        url = match.group(1)
        self.children = (RawText(url),)
        self.target = url
        self.title = ""

# %% ../nbs/05_mdmanager.ipynb 15
class Properties(Token):
    repr_attributes = ("key", "children")

    def __init__(self, key, value):
        self.key = key
        # Parse value recursively into proper span tokens
        self.children = self._parse_value(value)

    def _parse_value(self, value):
        """Recursively parse value into a flat list of span tokens."""
        if isinstance(value, str):
            stripped = value.strip()
            # Detect plain URLs and convert to AutoLink
            m = AnyLink.pattern.match(stripped)
            if m: return [AnyLink(m)]

            # Otherwise parse as regular inline markdown
            return span_token.tokenize_inner(stripped)
            # return span_token.tokenize_inner(value)

        elif isinstance(value, list):
            tokens = []
            for v in value:
                tokens.extend(self._parse_value(v))
            return tokens

        elif isinstance(value, dict):
            tokens = []
            for k, v in value.items():
                tokens.extend(self._parse_value(v))
            return tokens

        else:
            # Fallback for non-string values
            return [RawText(str(value))]

# %% ../nbs/05_mdmanager.ipynb 16
class TagLink(Link):
    """
    Obsidian-style tag link #tag that behaves like a mistletoe.Link.
    Renders to <a href="/tags/tag">#tag</a> or similar.
    """
    # Matches hashtags at word boundaries: # followed by word characters/dashes
    pattern = re.compile(r'(?<!\w)#([\w\-]+)')
    parse_group = 0
    parse_inner = False

    def __init__(self, match):
        tag_name = match.group(1)

        # URL target (you can change the prefix to match your app)
        self.target = MountPaths.tag.to(tag=tag_name)
        self.title = ""
        self.label = None
        self.dest_type = "taglink"
        self.title_delimiter = None

        # Displayed text is "#tag"
        self.children = [RawText(f"#{tag_name}")]

# %% ../nbs/05_mdmanager.ipynb 17
class Frontmatter(BlockToken):
    """
    YAML Frontmatter token.
    This is a leaf block token that captures metadata enclosed by --- ... ---.
    """

    repr_attributes = BlockToken.repr_attributes + ("data",)

    # Match `---` followed by anything until the next `---` on its own line
    # pattern = re.compile(
    #     r'(?ms)^(?:---)\s*\n(.*?)(?:\n---\s*$)'
    # )

    pattern = re.compile(
        r'(?ms)\A---\s*\n(.*?)(?:\n---\s*\n)'
    )

    def __init__(self, content: str):
        self.content = content.strip()
        try:
            parsed = yaml.safe_load(self.content) or {}
        except yaml.YAMLError as e:
            parsed = {"error": str(e)}


        if isinstance(parsed, dict):
            self.data = parsed
        else:
            # wrap scalars/lists into a dict
            self.data = {"value": parsed}
        
        # Process the YAML data into children, parsing each value as markdown
        self.children = []
        
        for k, v in self.data.items():
            if k.lower() == "tags":
                tags = v if isinstance(v, list) else [v]
                            # Prepend "#" so later inline parsing makes TagLinks
                processed = [f"#{t}" for t in tags if isinstance(t, str)]
                self.children.append(Properties(k, processed))
            else: self.children.append(Properties(k, v))

    @classmethod
    def start(cls, line: str) -> bool:
        # Only starts if line is `---`
        return line.strip() == "---"

    @classmethod
    def check_interrupts_paragraph(cls, lines):
        return cls.start(lines.peek())

    @classmethod
    def read(cls, lines):
        if lines.line_number() > 1:
            return None 
        # Consume first line (`---`)
        next(lines)
        buffer = []
        for line in lines:
            if line.strip() == "---":
                break
            buffer.append(line)
        return "".join(buffer)

# %% ../nbs/05_mdmanager.ipynb 18
class ObsidianAstRenderer(AstRenderer):
    def __init__(self,  **kwargs):
        super().__init__(Frontmatter, WikiLink, TagLink, AnyLink, ObsidianLink, ObsidianEmbed,  **kwargs)  # register custom token

    def render_obsidian_embed(self, token):
        return self.render_link(token)
    
    def render_obsidian_link(self, token):
        return self.render_link(token)

    def render_wiki_link(self, token):
        return self.render_link(token)

    def render_any_link(self, token):
        return self.render_link(token)

    def render_tag_link(self, token):
        return self.render_link(token)
    
    def render_frontmatter(self, token: Frontmatter) -> dict:
        # Just return dict so AST expansion shows structured metadata
        return token.children

# %% ../nbs/05_mdmanager.ipynb 19
class ObsidianHTMLRenderer(HTMLRenderer):

    TEXTLIKE_EXTS = [".md", ".qmd", ".canvas", ".base"]
    IMGLIKE_EXTS = [".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"]

    def __init__(self, **kwargs):
        super().__init__(Frontmatter, WikiLink, TagLink, AnyLink, ObsidianLink, ObsidianEmbed,  **kwargs)  # register custom tokens

    def render_obsidian_embed(self, token):
        target = token.target
        ext = token.ext
        fname = token.fname
        if not (ext in self.IMGLIKE_EXTS or ext in self.TEXTLIKE_EXTS):
            return self.render_image(token)
        else:
            if ext in self.IMGLIKE_EXTS:
                return self.render_image(token)
            return self.render_link(token)
    
    def render_obsidian_link(self, token):
        return self.render_link(token)
        
    def render_wiki_link(self, token):
        return self.render_link(token)

    def render_any_link(self, token):
        return self.render_link(token)
    
    def render_tag_link(self, token):
        """Render TagLink as a span with tag styling."""
        return self.render_link(token)

    def render_frontmatter(self, token: Frontmatter) -> str:
        if not token.children:
            return '<div class="frontmatter"></div>'

        rows = []
        for prop in token.children:  # each is a Properties token
            key_html = f"<th>{prop.key}</th>"
            value_html = ", ".join(self.render(child) for child in prop.children)
            rows.append(f"<tr>{key_html}<td>{value_html}</td></tr>")

        return (
            '<div class="frontmatter">\n'
            '<table>\n'
            + "\n".join(rows)
            + "\n</table>\n</div>"
        )

# %% ../nbs/05_mdmanager.ipynb 21
def get_obsidianmd_ast(text):
    # span_token.add_token(Link)       # [text](url)
    # span_token.add_token(AutoLink)   # <http://example.com>
    span_token.add_token(ObsidianEmbed)
    span_token.add_token(ObsidianLink)
    span_token.add_token(WikiLink)
    block_token.add_token(Frontmatter)
    span_token.add_token(TagLink)
    return Document(text)

# %% ../nbs/05_mdmanager.ipynb 27
def print_ast(token, indent=0):
    pad = "  " * indent
    data = {k: v for k, v in getattr(token, "__dict__", {}).items() if not k.startswith("_")}
    print(f"{pad}{token.__class__.__name__}: {data}")
    
    # Safely iterate over children if present and iterable
    children = getattr(token, "children", None)
    if children:
        for child in children:
            print_ast(child, indent + 1)

# %% ../nbs/05_mdmanager.ipynb 28
def get_frontmatter(doc):
    for o in doc.children:
        if type(o).__name__ == 'Frontmatter': return o
    return None

# %% ../nbs/05_mdmanager.ipynb 29
def get_property(doc, key='title'):
    fm = get_frontmatter(doc)
    if fm:
        for p in fm.children:
            if p.key ==key: return p
    return None

# %% ../nbs/05_mdmanager.ipynb 30
def get_title(doc):
    p = get_property(doc, key='title'); 
    if p:
        o = p.children[0]
        return o.content
    return None
